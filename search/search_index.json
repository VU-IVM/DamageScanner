{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#damagescanner-direct-damage-assessments-for-natural-hazards","title":"DamageScanner: direct damage assessments for natural hazards","text":"<p>A python toolkit for direct damage assessments for natural hazards. Even though the method is initially developed for flood damage assessments, it can calculate damages for any hazard for which you just require a vulnerability curve (i.e. a one-dimensional relation). </p> <p>Please note: This package is still in development phase. In case of any problems, or if you have any suggestions for improvements, please raise an issue. </p>"},{"location":"#key-features","title":"\ud83d\udd11 Key Features","text":"<ul> <li>\u26a1 Modular design \u2014 Choose between raster-based or vector-based workflows</li> <li>\ud83d\udce6 Out-of-the-box methods \u2014 for exposure loading, raster-vector overlays, and damage estimation</li> <li>\ud83e\udde0 Damage functions \u2014 Apply your own vulnerability curves with flexible input formats</li> <li>\ud83d\uddfa\ufe0f Open geospatial stack \u2014 Built on GeoPandas, Rasterio, Shapely, and more</li> <li>\ud83e\uddea Easy API access \u2014 Use the Python interface directly or integrate into notebooks</li> </ul>"},{"location":"#background","title":"\ud83d\udcd6 Background","text":"<p>This package is (loosely) based on the original DamageScanner, which calculated potential flood damages based on inundation depth and land use using depth-damage curves in the Netherlands. The DamageScanner was originally developed for the 'Netherlands Later' project (Klijn et al., 2007). The original land-use classes were based on the Land-Use Scanner in order to evaluate the effect of future land-use change on flood damages. </p>"},{"location":"#quickstart","title":"\ud83d\ude80 Quickstart","text":"<ol> <li>Open the python environment in your command prompt or bash in which you want to install this package.</li> <li>Type <code>pip install damagescanner</code> and it should install itself into your python environment.</li> <li>Now you can import the package like any other package!</li> </ol>"},{"location":"#license","title":"\ud83d\udcc4 License","text":"<p>This project is licensed under the MIT License. See the LICENSE file for details.</p>"},{"location":"#funding","title":"\ud83c\udfdb\ufe0f Funding","text":"<p>This work has been supported by the following organizations and research programs:</p> <ul> <li>Global Facility for Disaster Reduction and Recovery (GFDRR) </li> <li>MIRACA Project \u2013 Grant Agreement No. 101093854  </li> <li>Dutch Research Council (NWO) \u2013 Veni Grant No. VI.Veni.194.033</li> </ul>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#core-module","title":"Core Module","text":""},{"location":"api/#damagescanner.core.DamageScanner.exposure","title":"<code>exposure(disable_progress=False, **kwargs)</code>","text":"<p>Run the exposure analysis.</p> <p>Identifies which features are affected by the hazard footprint, depending on the type of input data (raster or vector).</p> <p>Parameters:</p> Name Type Description Default <code>disable_progress</code> <code>bool</code> <p>If True, disables progress bars. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>Optional keyword arguments like <code>asset_type</code> (only for vector).</p> <code>{}</code> <p>Returns:</p> Type Description <p>geopandas.GeoDataFrame | xarray.DataArray: Affected assets or raster overlay result.</p>"},{"location":"api/#damagescanner.core.DamageScanner.calculate","title":"<code>calculate(disable_progress=False, save_output=False, **kwargs)</code>","text":"<p>Perform a damage calculation using the provided inputs.</p> <p>Applies vulnerability curves and maximum damage values to the exposed features or raster grid to calculate expected damage.</p> <p>Parameters:</p> Name Type Description Default <code>disable_progress</code> <code>bool</code> <p>If True, disables progress bars. Defaults to False.</p> <code>False</code> <code>save_output</code> <code>bool</code> <p>Not implemented. Placeholder for output saving option.</p> <code>False</code> <code>**kwargs</code> <p>asset_type (str, optional): Infrastructure class to evaluate. multi_curves (dict, optional): Mapping of asset types to curve sets. subtypes (list, optional): Used for subtype analysis.</p> <code>{}</code> <p>Returns:</p> Type Description <p>pd.DataFrame | xr.DataArray: Estimated damages for each asset or grid cell.</p>"},{"location":"api/#damagescanner.core.DamageScanner.risk","title":"<code>risk(hazard_dict, **kwargs)</code>","text":"<p>Perform a risk assessment across multiple hazard return periods.</p> <p>Integrates damages from each return period and computes expected annual damages. Supports both single and multi-curve inputs for infrastructure types.</p> <p>Parameters:</p> Name Type Description Default <code>hazard_dict</code> <code>dict</code> <p>Dictionary mapping return periods to hazard raster paths.</p> required <code>**kwargs</code> <p>asset_type (str, optional): Infrastructure class to evaluate. multi_curves (dict, optional): Mapping of asset types to curve sets.</p> <code>{}</code> <p>Returns:</p> Type Description <p>pd.DataFrame | None: A GeoDataFrame with risk values for each asset, or None if no results.</p>"},{"location":"api/#vector-based-specific-functions","title":"Vector-based Specific Functions","text":""},{"location":"api/#damagescanner.vector.VectorExposure","title":"<code>VectorExposure(hazard_file, feature_file, asset_type='roads', object_col='object_type', disable_progress=False)</code>","text":"<p>Load and overlay vector or raster hazard with vector exposure data.</p> <p>Parameters:</p> Name Type Description Default <code>hazard_file</code> <code>Path | Dataset | DatasetReader</code> <p>Hazard input.</p> required <code>feature_file</code> <code>Path | GeoDataFrame | DataFrame</code> <p>Exposure input.</p> required <code>asset_type</code> <code>str</code> <p>Infrastructure category (only for OSM).</p> <code>'roads'</code> <code>object_col</code> <code>str</code> <p>Name of the object type column.</p> <code>'object_type'</code> <code>disable_progress</code> <code>bool</code> <p>Whether to suppress progress bars.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>(features, object_col, hazard_crs, cell_area_m2)</p>"},{"location":"api/#damagescanner.vector.VectorScanner","title":"<code>VectorScanner(hazard_file, feature_file, curve_path, maxdam_path, asset_type='roads', multi_curves=dict(), object_col='object_type', disable_progress=False, **kwargs)</code>","text":"<p>Perform vector-based direct damage assessment using hazard and exposure layers.</p> <p>Parameters:</p> Name Type Description Default <code>hazard_file</code> <code>Path | Dataset | GeoDataFrame</code> <p>Hazard input.</p> required <code>feature_file</code> <code>Path | GeoDataFrame</code> <p>Exposure input.</p> required <code>curve_path</code> <code>Path | DataFrame</code> <p>Vulnerability curve(s).</p> required <code>maxdam_path</code> <code>Path | DataFrame | dict</code> <p>Maximum damage values.</p> required <code>asset_type</code> <code>str</code> <p>Infrastructure class (only for OSM).</p> <code>'roads'</code> <code>multi_curves</code> <code>dict</code> <p>Multiple curve sets.</p> <code>dict()</code> <code>object_col</code> <code>str</code> <p>Column name with object type.</p> <code>'object_type'</code> <code>disable_progress</code> <code>bool</code> <p>Whether to suppress progress bars.</p> <code>False</code> <p>Returns:</p> Type Description <p>gpd.GeoDataFrame: Exposure data with calculated damages.</p>"},{"location":"api/#raster-based-specific-functions","title":"Raster-based Specific Functions","text":""},{"location":"api/#damagescanner.raster.match_and_load_rasters","title":"<code>match_and_load_rasters(raster_in1, raster_in2)</code>","text":"<p>Match and clip two raster files to their common spatial extent and resolution.</p> <p>Code adapted from http://sciience.tumblr.com/post/101722591382/finding-the-georeferenced-intersection-between-two</p> <p>Parameters:</p> Name Type Description Default <code>raster_in1</code> <code>str or Path</code> <p>Path to the first raster file.</p> required <code>raster_in2</code> <code>str or Path</code> <p>Path to the second raster file.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <ul> <li>np.ndarray: Clipped raster array from the first file.</li> <li>np.ndarray: Clipped raster array from the second file.</li> <li>Affine: Affine transform of the intersecting region.</li> </ul>"},{"location":"api/#damagescanner.raster.RasterScanner","title":"<code>RasterScanner(exposure_file, hazard_file, curve_path, maxdam_path, lu_crs=28992, haz_crs=4326, hazard_col='FX', dtype=np.int32, save=False, **kwargs)</code>","text":"<p>Run a raster-based direct damage assessment using hazard and exposure layers.</p> <p>Parameters:</p> Name Type Description Default <code>exposure_file</code> <code>Path | ndarray</code> <p>Path to land-use GeoTIFF or numpy array.</p> required <code>hazard_file</code> <code>Path | ndarray | Dataset</code> <p>Path to hazard raster or dataset.</p> required <code>curve_path</code> <code>Path | DataFrame | ndarray</code> <p>Vulnerability curve(s).</p> required <code>maxdam_path</code> <code>Path | DataFrame | ndarray</code> <p>Maximum damage values.</p> required <code>lu_crs</code> <code>int</code> <p>CRS of the land-use file (default EPSG:28992).</p> <code>28992</code> <code>haz_crs</code> <code>int</code> <p>CRS of the hazard file (default EPSG:4326).</p> <code>4326</code> <code>hazard_col</code> <code>str</code> <p>Column containing hazard intensity (default \"FX\").</p> <code>'FX'</code> <code>dtype</code> <code>type</code> <p>Output dtype for damage raster.</p> <code>int32</code> <code>save</code> <code>bool</code> <p>If True, saves damage results to file.</p> <code>False</code> <p>Other Parameters:</p> Name Type Description <code>nan_value</code> <code>float</code> <p>Replace this value in the hazard raster with 0.</p> <code>cellsize</code> <code>float</code> <p>Cell size (m\u00b2) if exposure and hazard are arrays.</p> <code>resolution</code> <code>float</code> <p>Resolution in target projection (used for reprojection).</p> <code>output_path</code> <code>str or Path</code> <p>Output directory for saving results.</p> <code>scenario_name</code> <code>str</code> <p>Scenario name used for filenames.</p> <code>in_millions</code> <code>bool</code> <p>Convert results to millions.</p> <code>crs</code> <code>CRS</code> <p>CRS for saving output raster (optional).</p> <code>transform</code> <code>Affine</code> <p>Affine transform for saving raster (optional).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If cell size is not provided when required.</p> <code>ValueError</code> <p>If vulnerability or max damage file has invalid structure.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <ul> <li>pd.DataFrame: Damage per land-use category.</li> <li>np.ndarray: Damage map (grid with estimated damages).</li> <li>np.ndarray: Reprojected land-use map.</li> <li>np.ndarray: Reprojected hazard map.</li> </ul>"},{"location":"examples/overview/","title":"Overview","text":"<p><code>DamageScanner()</code> is a Python toolkit for direct damage assessments of natural hazards. While originally designed for flood risk analysis, it can be used for any hazard where vulnerability can be expressed as a one-dimensional curve (e.g., flood depth, wind speed, ground shaking).</p> <p>The tool is optimized for both raster-based (e.g. land use) and vector-based (e.g., roads, power plants, buildings) damage assessments. This page walks you through how it works, and what is required for running a successful analysis.</p> <p>\ud83d\udcda For a very extensive overview of real-world examples, please refer to the GlobalInfraRisk documentation.</p>"},{"location":"examples/overview/#core-workflow","title":"Core Workflow","text":"<p>The DamageScanner logic consists of three key steps:</p> <ol> <li>Exposure Analysis \u2014 identifies what assets intersect the hazard.</li> <li>Damage Calculation \u2014 estimates damage using vulnerability curves.</li> <li>Risk Assessment \u2014 aggregates damage across hazard return periods.</li> </ol>"},{"location":"examples/overview/#inputs-required","title":"Inputs Required","text":"<p>The <code>DamageScanner</code> class requires four key inputs:</p>"},{"location":"examples/overview/#1-hazard-data","title":"1. Hazard Data","text":"<ul> <li>Raster (GeoTIFF, NetCDF) or path to raster files</li> <li>Represents hazard intensity (e.g., flood depth, wind speed)</li> </ul>"},{"location":"examples/overview/#2-exposure-data-aka-feature_data","title":"2. Exposure Data (aka <code>feature_data</code>)","text":"<ul> <li>Vector formats: <code>.shp</code>, <code>.gpkg</code>, <code>.pbf</code>, <code>.geoparquet</code>, or GeoDataFrames</li> <li>Raster exposure layers (<code>.tif</code>, <code>.nc</code>) also supported</li> <li>Automatically detects type from file extension</li> </ul>"},{"location":"examples/overview/#3-vulnerability-curves","title":"3. Vulnerability Curves","text":"<ul> <li>CSV or <code>pandas.DataFrame</code></li> <li>Relates hazard intensity to damage (as fraction of max damage)</li> </ul> <p>\u26a0\ufe0f Important: The unit of the first column/index must match the unit of the hazard layer (e.g., meters for flood depth).</p>"},{"location":"examples/overview/#4-maximum-damage-values","title":"4. Maximum Damage Values","text":"<ul> <li>Specifies the max value per asset type (e.g., \u20ac/m\u00b2 or \u20ac/asset)</li> <li>Provided as <code>dict</code>, CSV, or DataFrame</li> </ul>"},{"location":"examples/overview/#example-running-damagescanner","title":"Example: Running DamageScanner","text":"<pre><code>from damagescanner import DamageScanner\nimport pandas as pd\n\n# Paths to input files\nhazard = \"path/to/hazard_data.tif\"\nfeature_data = \"path/to/exposure_data.shp\"\ncurves = \"path/to/vulnerability_curves.csv\"\nmaxdam = \"path/to/maxdam.csv\"\n\n# Initialize\nscanner = DamageScanner(hazard, feature_data, curves, maxdam)\n</code></pre>"},{"location":"examples/overview/#step-by-step-usage","title":"Step-by-Step Usage","text":""},{"location":"examples/overview/#1-exposure","title":"1. <code>exposure()</code>","text":"<p>Identify which features overlap with the hazard.</p> <pre><code># Curves and maxdam must be empty DataFrames for exposure-only\nscanner = DamageScanner(hazard, feature_data, pd.DataFrame(), pd.DataFrame())\nexposed = scanner.exposure()\n</code></pre> <ul> <li>Works with both vector and raster feature data</li> <li>Results in a GeoDataFrame with assets intersecting the hazard</li> </ul>"},{"location":"examples/overview/#2-calculate","title":"2. <code>calculate()</code>","text":"<p>Applies vulnerability curves to estimate damage.</p> <pre><code>results = scanner.calculate()\nprint(results.head())\n</code></pre> <ul> <li>Requires valid curves and <code>maxdam</code></li> <li>Damage is computed per asset, based on overlap and intensity</li> </ul>"},{"location":"examples/overview/#3-risk","title":"3. <code>risk()</code>","text":"<p>Calculates risk over multiple return periods.</p> <pre><code>hazard_dict = {\n    10: \"hazard_10.tif\",\n    50: \"hazard_50.tif\",\n    100: \"hazard_100.tif\"\n}\n\nrisk_results = scanner.risk(hazard_dict)\n</code></pre> <ul> <li>Computes Expected Annual Damages (EAD) using return periods</li> <li>Supports asset-specific curves and max damages</li> </ul>"},{"location":"examples/overview/#tips-for-working-with-geometry","title":"Tips for Working with Geometry","text":"<p>\u26a0\ufe0f Important: Make sure each asset type uses one geometry type (Point or Polygon). Options:</p> <ol> <li>Convert all assets to the same geometry</li> <li>Split the damage calc by geometry type</li> <li>Use custom object names like <code>substation_point</code> vs <code>substation_polygon</code></li> </ol>"},{"location":"examples/overview/#next-steps","title":"\ud83d\udcda Next Steps","text":"<ul> <li>\ud83d\udce6 Raster-based approach</li> <li>\ud83d\udce6 Vector-based approach</li> <li>\ud83e\udded Coupling with OSM</li> </ul>"},{"location":"examples/raster-based/","title":"Raster-based Example (Kampen)","text":"<p>This example demonstrates how to run the raster-based flood damage assessment using a land-use map for the Kampen region in the Netherlands.</p>"},{"location":"examples/raster-based/#1-import-dependencies","title":"1. Import Dependencies","text":"<pre><code>import pandas as pd\nfrom damagescanner.raster import RasterScanner\n</code></pre>"},{"location":"examples/raster-based/#2-load-input-data-from-github","title":"2. Load Input Data from GitHub","text":"<p>We use publicly available data from the DamageScanner GitHub repository:</p> <pre><code>hazard_file = \"https://raw.githubusercontent.com/VU-IVM/DamageScanner/installation/data/kampen/hazard/1in1000_inundation_map.tif\"\nlanduse_file = \"https://raw.githubusercontent.com/VU-IVM/DamageScanner/installation/data/kampen/exposure/landuse_map.tif\"\ncurve_file = \"https://raw.githubusercontent.com/VU-IVM/DamageScanner/installation/data/kampen/vulnerability/curves.csv\"\nmaxdam_file = \"https://raw.githubusercontent.com/VU-IVM/DamageScanner/installation/data/kampen/vulnerability/maxdam.csv\"\n</code></pre>"},{"location":"examples/raster-based/#3-load-vulnerability-data","title":"3. Load Vulnerability Data","text":"<pre><code>curves = pd.read_csv(curve_file)\nmaxdam = pd.read_csv(maxdam_file)\n</code></pre>"},{"location":"examples/raster-based/#4-run-the-raster-based-damage-assessment","title":"4. Run the Raster-Based Damage Assessment","text":"<pre><code>damage_df, damagemap, landuse_data, hazard_data = RasterScanner(\n    landuse_file,\n    hazard_file,\n    curves,\n    maxdam,\n)\n</code></pre>"},{"location":"examples/raster-based/#5-display-output","title":"5. Display Output","text":"<pre><code>damage_df.head()\n</code></pre>"},{"location":"examples/vector-based/","title":"Vector-based Example (Kampen)","text":"<p>This example demonstrates how to run the vector-based flood damage assessment using OSM exposure data for the Kampen region in the Netherlands.</p>"},{"location":"examples/vector-based/#1-import-dependencies","title":"1. Import Dependencies","text":"<pre><code>import pandas as pd\nimport damagescanner\nfrom damagescanner.core import DamageScanner\n</code></pre>"},{"location":"examples/vector-based/#2-load-input-data-from-github","title":"2. Load Input Data from GitHub","text":"<p>We use publicly available data from the DamageScanner GitHub repository:</p> <pre><code>hazard_file = \"https://raw.githubusercontent.com/VU-IVM/DamageScanner/installation/data/kampen/hazard/1in1000_inundation_map.tif\"\nexposure_file = \"https://raw.githubusercontent.com/VU-IVM/DamageScanner/installation/data/kampen/exposure/kampen.osm.pbf\"\ncurve_file = \"https://raw.githubusercontent.com/VU-IVM/DamageScanner/installation/data/kampen/vulnerability/curves_osm.csv\"\nmaxdam_file = \"https://raw.githubusercontent.com/VU-IVM/DamageScanner/installation/data/kampen/vulnerability/maxdam_osm.csv\"\n</code></pre>"},{"location":"examples/vector-based/#3-load-vulnerability-data","title":"3. Load Vulnerability Data","text":"<pre><code>curves = pd.read_csv(curve_file)\nmaxdam = pd.read_csv(maxdam_file)\n</code></pre>"},{"location":"examples/vector-based/#4-run-the-vector-based-damage-assessment","title":"4. Run the Vector-Based Damage Assessment","text":"<pre><code>scanner = DamageScanner(hazard_file, exposure_file, curves, maxdam)\nfeatures = scanner.calculate(asset_type='main_roads')\n</code></pre>"},{"location":"examples/vector-based/#5-display-output","title":"5. Display Output","text":"<pre><code>features[[\"object_type\", \"geometry\", \"damage\"]].head()\n</code></pre>"},{"location":"how-to/osm/","title":"Coupling with OpenStreetMap (OSM)","text":"<p>One of the powerful features of <code>DamageScanner</code> is the ability to work with OpenStreetMap (OSM) data as exposure input. This enables fast and global-scale exposure mapping, using freely available, crowdsourced infrastructure data.</p> <p>This page outlines how to prepare and use OSM data for damage assessment workflows, using <code>.osm.pbf</code> files directly.</p>"},{"location":"how-to/osm/#why-use-osm-data","title":"Why Use OSM Data?","text":"<ul> <li>Freely available, global coverage</li> <li>Includes many infrastructure types (roads, buildings, energy, healthcare, etc.)</li> <li>Constantly updated by the global community</li> <li>Works well with vector-based workflows in <code>DamageScanner</code></li> </ul> <p>\u26a0\ufe0f Note: OSM data quality and completeness can vary by location. Always validate your input.</p>"},{"location":"how-to/osm/#how-damagescanner-works-with-osm","title":"How DamageScanner Works with OSM","text":"<p>DamageScanner includes built-in support for working directly with <code>.osm.pbf</code> files. The tool provides utilities to:</p> <ul> <li>Download <code>.osm.pbf</code> files from Geofabrik</li> <li>Extract specific infrastructure classes</li> <li>Clean and preprocess the data into usable <code>GeoDataFrame</code> or <code>.gpkg</code></li> </ul> <p>These functions are implemented in: - <code>osm.py</code> - <code>download.py</code></p> <p>\u2705 This approach allows for highly automated and reproducible integration of OSM infrastructure.</p> <p>You can extract features like this:</p> <pre><code>from damagescanner.osm import read_osm_data\n\n# Read critical infrastructure data from an OSM .pbf file\nosm_path = \"data/netherlands-latest.osm.pbf\"\nfeatures = read_osm_data(osm_path, asset_type=\"road\")\n</code></pre> <p>The <code>asset_type</code> must be one of the predefined keys such as <code>road</code>, <code>rail</code>, <code>power</code>, <code>healthcare</code>, <code>education</code>, etc. The output is a cleaned GeoDataFrame with valid geometries and an <code>object_type</code> column.</p>"},{"location":"how-to/osm/#manual-tagging-optional","title":"Manual Tagging (Optional)","text":"<p>If you're preparing custom OSM files manually (e.g. from <code>.shp</code> or <code>.gpkg</code>):</p> <pre><code># Reproject and tag manually loaded GeoDataFrame\ngdf = gdf.to_crs(\"EPSG:32633\")\ngdf = gdf[gdf.geom_type.isin([\"LineString\", \"MultiLineString\"])]\ngdf[\"object_type\"] = \"road\"\n</code></pre> <p>\u26a0\ufe0f The required column name is always <code>object_type</code> \u2014 this is how DamageScanner matches features with vulnerability curves and max damage values.</p> <p>Save to file if needed:</p> <pre><code>gdf.to_file(\"data/cleaned_osm_roads.gpkg\", driver=\"GPKG\")\n</code></pre>"},{"location":"how-to/osm/#example-usage-with-damagescanner","title":"Example Usage with DamageScanner","text":"<pre><code>from damagescanner import DamageScanner\n\nhazard = \"data/flood_depth_100yr.tif\"\nosm_exposure = \"data/cleaned_osm_roads.gpkg\"\ncurves = \"data/vulnerability_curves.csv\"\nmaxdam = \"data/maxdam.csv\"\n\nscanner = DamageScanner(hazard, osm_exposure, curves, maxdam)\ndamage = scanner.calculate()\n</code></pre> <p>This calculates direct damages using cleaned vector infrastructure data from OSM.</p>"},{"location":"how-to/osm/#tips-for-reproducibility","title":"Tips for Reproducibility","text":"<ul> <li>Document the OSM extract date and source (e.g. Geofabrik region)</li> <li>Use consistent object naming (e.g. <code>road</code>, <code>bridge</code>, <code>hospital</code>) to match your vulnerability inputs</li> <li>Save your processed data in <code>.gpkg</code> or <code>.shp</code> format for reuse</li> </ul>"},{"location":"how-to/osm/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>Overview</li> <li>Raster-based approach</li> <li>Vector-based approach</li> <li>GlobalInfraRisk OSM Guide</li> </ul>"},{"location":"how-to/overview/","title":"Overview","text":"<p><code>DamageScanner()</code> is a Python toolkit for direct damage assessments of natural hazards. While originally designed for flood risk analysis, it can be used for any hazard where vulnerability can be expressed as a one-dimensional curve (e.g., flood depth, wind speed, ground shaking).</p> <p>The tool is optimized for both raster-based (e.g. land use) and vector-based (e.g., roads, power plants, buildings) damage assessments. This page walks you through how it works, and what is required for running a successful analysis.</p> <p>\ud83d\udcda For a very extensive overview of real-world examples, please refer to the GlobalInfraRisk documentation.</p>"},{"location":"how-to/overview/#core-workflow","title":"Core Workflow","text":"<p>The DamageScanner logic consists of three key steps:</p> <ol> <li>Exposure Analysis \u2014 identifies what assets intersect the hazard.</li> <li>Damage Calculation \u2014 estimates damage using vulnerability curves.</li> <li>Risk Assessment \u2014 aggregates damage across hazard return periods.</li> </ol>"},{"location":"how-to/overview/#inputs-required","title":"Inputs Required","text":"<p>The <code>DamageScanner</code> class requires four key inputs:</p>"},{"location":"how-to/overview/#1-hazard-data","title":"1. Hazard Data","text":"<ul> <li>Raster (GeoTIFF, NetCDF) or path to raster files</li> <li>Represents hazard intensity (e.g., flood depth, wind speed)</li> </ul>"},{"location":"how-to/overview/#2-exposure-data-aka-feature_data","title":"2. Exposure Data (aka <code>feature_data</code>)","text":"<ul> <li>Vector formats: <code>.shp</code>, <code>.gpkg</code>, <code>.pbf</code>, <code>.geoparquet</code>, or GeoDataFrames</li> <li>Raster exposure layers (<code>.tif</code>, <code>.nc</code>) also supported</li> <li>Automatically detects type from file extension</li> </ul>"},{"location":"how-to/overview/#3-vulnerability-curves","title":"3. Vulnerability Curves","text":"<ul> <li>CSV or <code>pandas.DataFrame</code></li> <li>Relates hazard intensity to damage (as fraction of max damage)</li> </ul> <p>\u26a0\ufe0f Important: The unit of the first column/index must match the unit of the hazard layer (e.g., meters for flood depth).</p>"},{"location":"how-to/overview/#4-maximum-damage-values","title":"4. Maximum Damage Values","text":"<ul> <li>Specifies the max value per asset type (e.g., \u20ac/m\u00b2 or \u20ac/asset)</li> <li>Provided as <code>dict</code>, CSV, or DataFrame</li> </ul>"},{"location":"how-to/overview/#example-running-damagescanner","title":"Example: Running DamageScanner","text":"<pre><code>from damagescanner import DamageScanner\nimport pandas as pd\n\n# Paths to input files\nhazard = \"path/to/hazard_data.tif\"\nfeature_data = \"path/to/exposure_data.shp\"\ncurves = \"path/to/vulnerability_curves.csv\"\nmaxdam = \"path/to/maxdam.csv\"\n\n# Initialize\nscanner = DamageScanner(hazard, feature_data, curves, maxdam)\n</code></pre>"},{"location":"how-to/overview/#step-by-step-usage","title":"Step-by-Step Usage","text":""},{"location":"how-to/overview/#1-exposure","title":"1. <code>exposure()</code>","text":"<p>Identify which features overlap with the hazard.</p> <pre><code># Curves and maxdam must be empty DataFrames for exposure-only\nscanner = DamageScanner(hazard, feature_data, pd.DataFrame(), pd.DataFrame())\nexposed = scanner.exposure()\n</code></pre> <ul> <li>Works with both vector and raster feature data</li> <li>Results in a GeoDataFrame with assets intersecting the hazard</li> </ul>"},{"location":"how-to/overview/#2-calculate","title":"2. <code>calculate()</code>","text":"<p>Applies vulnerability curves to estimate damage.</p> <pre><code>results = scanner.calculate()\nprint(results.head())\n</code></pre> <ul> <li>Requires valid curves and <code>maxdam</code></li> <li>Damage is computed per asset, based on overlap and intensity</li> </ul>"},{"location":"how-to/overview/#3-risk","title":"3. <code>risk()</code>","text":"<p>Calculates risk over multiple return periods.</p> <pre><code>hazard_dict = {\n    10: \"hazard_10.tif\",\n    50: \"hazard_50.tif\",\n    100: \"hazard_100.tif\"\n}\n\nrisk_results = scanner.risk(hazard_dict)\n</code></pre> <ul> <li>Computes Expected Annual Damages (EAD) using return periods</li> <li>Supports asset-specific curves and max damages</li> </ul>"},{"location":"how-to/overview/#tips-for-working-with-geometry","title":"Tips for Working with Geometry","text":"<p>\u26a0\ufe0f Important: Make sure each asset type uses one geometry type (Point or Polygon). Options:</p> <ol> <li>Convert all assets to the same geometry</li> <li>Split the damage calc by geometry type</li> <li>Use custom object names like <code>substation_point</code> vs <code>substation_polygon</code></li> </ol>"},{"location":"how-to/overview/#next-steps","title":"\ud83d\udcda Next Steps","text":"<ul> <li>\ud83d\udce6 Raster-based approach</li> <li>\ud83d\udce6 Vector-based approach</li> <li>\ud83e\udded Coupling with OSM</li> </ul>"},{"location":"how-to/raster/","title":"Raster-based Approach","text":"<p>This page explains how to use <code>DamageScanner</code> with raster-based exposure and hazard data. This approach is especially useful when working with gridded exposure datasets, such as population grids, land use rasters, or economic value rasters.</p>"},{"location":"how-to/raster/#when-to-use-raster-based-workflows","title":"When to Use Raster-Based Workflows","text":"Scenario Raster-Based Vector-Based Gridded exposure data (e.g. land cover) \u2705 \u274c Building footprints or linear infrastructure \u274c \u2705 Country- or global-scale risk analysis \u2705 \u2705 Exposure not tied to individual assets \u2705 \u274c"},{"location":"how-to/raster/#required-inputs","title":"Required Inputs","text":"<p>You still need the same four key inputs as explained in the Overview:</p> <ol> <li>Hazard raster (e.g. flood depth, wind speed)</li> <li>Exposure raster (e.g. land use, population density)</li> <li>Vulnerability curves (CSV or DataFrame)</li> <li>Maximum damage values (CSV, dict, or DataFrame)</li> </ol> <p>\u26a0\ufe0f Ensure both hazard and exposure rasters are in the same CRS and aligned spatially (same resolution and extent) for optimal performance.</p>"},{"location":"how-to/raster/#minimal-working-example","title":"Minimal Working Example","text":"<pre><code>from damagescanner import DamageScanner\n\nhazard = \"data/hazard_flood_depth.tif\"\nfeature_data = \"data/exposure_population_density.tif\"\ncurves = \"data/vulnerability_curves.csv\"\nmaxdam = \"data/maxdam.csv\"\n\nscanner = DamageScanner(hazard, feature_data, curves, maxdam)\ndamage = scanner.calculate()\n</code></pre> <p>This returns a <code>GeoDataFrame</code> where each grid cell contains an estimated direct damage value.</p>"},{"location":"how-to/raster/#notes-on-raster-behavior","title":"Notes on Raster Behavior","text":"<ul> <li>Exposure values are interpreted as damageable units per cell (e.g., people, \u20ac value, or m\u00b2)</li> <li>Output damage is computed as:</li> </ul> <p>\\   <code>exposure * damage_fraction * max_damage</code></p> <ul> <li>The damage fraction is determined from the vulnerability curve, based on the hazard intensity in the same raster cell.</li> </ul>"},{"location":"how-to/raster/#common-pitfalls","title":"Common Pitfalls","text":"<p>\u26a0\ufe0f Misaligned Rasters \u2014 Make sure both rasters have the same extent, resolution, and CRS. You can use <code>rasterio.warp</code> or <code>gdalwarp</code> to resample.</p> <p>\u26a0\ufe0f Missing Data \u2014 NoData values can propagate through your analysis. Clean them or mask them before calculation.</p> <p>\u26a0\ufe0f Unit mismatch \u2014 Hazard units and curve x-axis must match exactly (e.g., meters, m/s).</p>"},{"location":"how-to/raster/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>Overview</li> <li>Vector-based approach</li> <li>Coupling with OSM</li> </ul>"},{"location":"how-to/vector/","title":"Vector-based Approach","text":"<p>This page explains how to use <code>DamageScanner</code> with vector-based exposure data (e.g. shapefiles, GeoPackages, or OSM data). This approach is ideal for object-level damage estimation, such as buildings, roads, power plants, and other individual infrastructure assets.</p>"},{"location":"how-to/vector/#when-to-use-vector-based-workflows","title":"When to Use Vector-Based Workflows","text":"Scenario Raster-Based Vector-Based Infrastructure objects (e.g. bridges, roads) \u274c \u2705 OpenStreetMap data \u274c \u2705 Detailed local studies \u274c \u2705 Exposure linked to specific geometries \u274c \u2705"},{"location":"how-to/vector/#required-inputs","title":"Required Inputs","text":"<p>As described in the Overview, you need:</p> <ol> <li>Hazard raster (e.g. flood depth, wind speed)</li> <li>Exposure vector (e.g. buildings, roads \u2014 as <code>.shp</code>, <code>.gpkg</code>, <code>.pbf</code>, or <code>GeoDataFrame</code>)</li> <li>Vulnerability curves (CSV or DataFrame)</li> <li>Maximum damage values (CSV, dict, or DataFrame)</li> </ol> <p>\u26a0\ufe0f Your exposure data must include a column specifying asset type, matching the keys used in the vulnerability curves and max damage data.</p>"},{"location":"how-to/vector/#minimal-working-example","title":"Minimal Working Example","text":"<pre><code>from damagescanner import DamageScanner\n\nhazard = \"data/hazard_flood_depth.tif\"\nfeature_data = \"data/infrastructure_osm.gpkg\"\ncurves = \"data/vulnerability_curves.csv\"\nmaxdam = \"data/maxdam.csv\"\n\nscanner = DamageScanner(hazard, feature_data, curves, maxdam)\ndamage = scanner.calculate()\n</code></pre> <p>The result is a <code>GeoDataFrame</code> of features with estimated direct damage values per asset.</p>"},{"location":"how-to/vector/#key-behavior","title":"Key Behavior","text":"<ul> <li>The exposure file must contain geometry columns (Point, LineString, or Polygon)</li> <li><code>DamageScanner</code> overlays each geometry with the hazard raster</li> <li>It then samples the hazard value and looks up the damage fraction from the corresponding vulnerability curve</li> <li>The damage is calculated as:</li> </ul> <p>\\   <code>exposure_area * damage_fraction * max_damage</code></p>"},{"location":"how-to/vector/#geometry-handling-tips","title":"\u26a0\ufe0f Geometry Handling Tips","text":"<p>\u26a0\ufe0f Mixed Geometry Types \u2014 Avoid mixing Points and Polygons for the same asset type.</p> <p>\u26a0\ufe0f CRS Alignment \u2014 Both hazard and vector data must be in the same coordinate reference system.</p> <p>\u26a0\ufe0f Object Column \u2014 You must define a column that links each object to a vulnerability curve and max damage.</p>"},{"location":"how-to/vector/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>Overview</li> <li>Raster-based approach</li> <li>Coupling with OSM</li> </ul>"}]}